//!
//! generated by flatc-zig
//! binary:     gen/home/travis/Downloads/flatbuffers/reflection/reflection.bfbs
//! schema:     /home/travis/Downloads/flatbuffers/reflection/reflection.fbs
//! file ident: //reflection.fbs
//! typename    reflection.Type
//!

const std = @import("std");
const fb = @import("flatbufferz");
const Builder = fb.Builder;

// a namespace generated by flatc-zig to match typenames produced by flatc
const reflection = struct {
    const BaseType = @import("BaseType.fb.zig").BaseType;
    const Type = @import("Type.fb.zig").Type;
    const TypeT = @import("Type.fb.zig").TypeT;
};

pub const Type = struct {
    _tab: fb.Table,

    pub fn GetRootAs(buf: []u8, offset: u32) reflection.Type {
        const n = fb.encode.read(u32, buf[offset..]);
        return reflection.Type.init(buf, n + offset);
    }

    pub fn GetSizePrefixedRootAs(buf: []u8, offset: u32) reflection.Type {
        const n = fb.encode.read(u32, buf[offset + fb.Builder.size_u32 ..]);
        return reflection.Type.init(buf, n + offset + fb.Builder.size_u32);
    }

    pub fn init(bytes: []u8, pos: u32) Type {
        return .{ ._tab = .{ .bytes = bytes, .pos = pos } };
    }

    pub fn Table(x: Type) fb.Table {
        return x._tab;
    }

    pub fn BaseType(rcv: Type) reflection.BaseType {
        const o = rcv._tab.offset(4);
        if (o != 0) {
            return rcv._tab.read(reflection.BaseType, o + rcv._tab.pos);
        }
        return @intToEnum(reflection.BaseType, 0);
    }

    pub fn MutateBaseType(rcv: Type, n: reflection.BaseType) bool {
        return rcv._tab.mutateSlot(reflection.BaseType, 4, n);
    }

    pub fn Element(rcv: Type) reflection.BaseType {
        const o = rcv._tab.offset(6);
        if (o != 0) {
            return rcv._tab.read(reflection.BaseType, o + rcv._tab.pos);
        }
        return @intToEnum(reflection.BaseType, 0);
    }

    pub fn MutateElement(rcv: Type, n: reflection.BaseType) bool {
        return rcv._tab.mutateSlot(reflection.BaseType, 6, n);
    }

    pub fn Index(rcv: Type) i32 {
        const o = rcv._tab.offset(8);
        if (o != 0) {
            return rcv._tab.read(i32, o + rcv._tab.pos);
        }
        return -1;
    }

    pub fn MutateIndex(rcv: Type, n: i32) bool {
        return rcv._tab.mutateSlot(i32, 8, n);
    }

    pub fn FixedLength(rcv: Type) u16 {
        const o = rcv._tab.offset(10);
        if (o != 0) {
            return rcv._tab.read(u16, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateFixedLength(rcv: Type, n: u16) bool {
        return rcv._tab.mutateSlot(u16, 10, n);
    }

    /// The size (octets) of the `base_type` field.
    pub fn BaseSize(rcv: Type) u32 {
        const o = rcv._tab.offset(12);
        if (o != 0) {
            return rcv._tab.read(u32, o + rcv._tab.pos);
        }
        return 4;
    }

    pub fn MutateBaseSize(rcv: Type, n: u32) bool {
        return rcv._tab.mutateSlot(u32, 12, n);
    }

    /// The size (octets) of the `element` field, if present.
    pub fn ElementSize(rcv: Type) u32 {
        const o = rcv._tab.offset(14);
        if (o != 0) {
            return rcv._tab.read(u32, o + rcv._tab.pos);
        }
        return 0;
    }

    pub fn MutateElementSize(rcv: Type, n: u32) bool {
        return rcv._tab.mutateSlot(u32, 14, n);
    }

    pub fn Start(__builder: *Builder) !void {
        try __builder.startObject(6);
    }
    pub fn AddBaseType(__builder: *Builder, base_type: reflection.BaseType) !void {
        try __builder.prependSlot(reflection.BaseType, 0, base_type, @intToEnum(reflection.BaseType, 0));
    }

    pub fn AddElement(__builder: *Builder, element: reflection.BaseType) !void {
        try __builder.prependSlot(reflection.BaseType, 1, element, @intToEnum(reflection.BaseType, 0));
    }

    pub fn AddIndex(__builder: *Builder, index: i32) !void {
        try __builder.prependSlot(i32, 2, index, -1);
    }

    pub fn AddFixedLength(__builder: *Builder, fixed_length: u16) !void {
        try __builder.prependSlot(u16, 3, fixed_length, 0);
    }

    pub fn AddBaseSize(__builder: *Builder, base_size: u32) !void {
        try __builder.prependSlot(u32, 4, base_size, 4);
    }

    pub fn AddElementSize(__builder: *Builder, element_size: u32) !void {
        try __builder.prependSlot(u32, 5, element_size, 0);
    }

    pub fn End(__builder: *Builder) !u32 {
        return __builder.endObject();
    }
};
